const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    // Create Supabase client
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    const openaiKey = Deno.env.get('OPENAI_API_KEY')!
    
    if (!openaiKey) {
      console.log('OpenAI API key not configured, using fallback generation')
      return await generateFallbackGame(supabaseUrl, supabaseKey)
    }

    // Parse request body to get user prompt
    let userPrompt = '';
    let isAutoGenerated = false;
    try {
      const body = await req.json();
      userPrompt = body.user_prompt || '';
      isAutoGenerated = body.auto_generated || false;
    } catch (error) {
      console.log('No request body or invalid JSON, proceeding without user prompt');
    }

    console.log('Starting game generation:', { 
      userPrompt: userPrompt || 'No prompt provided',
      isAutoGenerated 
    });
    
    // Generate game idea with user prompt or random generation
    let ideaPrompt = '';
    
    if (userPrompt.trim()) {
      // Use user's prompt directly
      ideaPrompt = `Create a unique browser mini-game based on this description: "${userPrompt}"

REQUIREMENTS:
- Must be playable in a web browser
- Should be fun and engaging
- Include clear objectives and controls
- Make it creative and unique
- Keep the core concept focused

Format: 
Title: [Creative Game Name]
Description: [One sentence describing the core gameplay]`;
    } else {
      // Generate random game idea
      const gameTypes = [
        "endless runner with unique mechanics",
        "puzzle game with physics",
        "arcade shooter with power-ups",
        "platformer with special abilities",
        "rhythm-based action game",
        "maze navigation challenge",
        "reaction time tester",
        "memory pattern game",
        "resource management mini-game",
        "physics-based destruction game"
      ];
      
      const themes = [
        "space exploration",
        "underwater adventure",
        "magical forest",
        "cyberpunk city",
        "ancient temple",
        "candy world",
        "robot factory",
        "dinosaur era",
        "alien planet",
        "steampunk laboratory"
      ];
      
      const mechanics = [
        "collect items while avoiding obstacles",
        "match patterns under time pressure",
        "stack objects without falling",
        "navigate through moving barriers",
        "defend against waves of enemies",
        "solve puzzles to progress",
        "race against the clock",
        "balance resources carefully",
        "chain combos for higher scores",
        "survive as long as possible"
      ];
      
      const randomType = gameTypes[Math.floor(Math.random() * gameTypes.length)];
      const randomTheme = themes[Math.floor(Math.random() * themes.length)];
      const randomMechanic = mechanics[Math.floor(Math.random() * mechanics.length)];
      
      ideaPrompt = `Create a unique ${randomType} set in a ${randomTheme} where the player must ${randomMechanic}.

REQUIREMENTS:
- Must be completely different from typical games
- Unique control scheme (not just arrow keys)
- Creative visual style and colors
- Unexpected gameplay twist
- Clear win/lose conditions
- Should feel fresh and original

Examples of CREATIVE concepts:
- "Gravity-switching space janitor cleaning cosmic debris"
- "Time-rewinding ninja avoiding laser grids"
- "Color-mixing wizard painting portals to escape"
- "Sound-wave surfer riding music through dimensions"

Format: 
Title: [Creative Unique Name]
Description: [One sentence describing the unique core gameplay]`;
    }
    
    let title = 'Mystery Game';
    let description = 'A unique gaming experience';
    let gameCode = '';
    let thumbnailUrl = '/placeholder.png';
    
    try {
      // Generate idea first
      console.log('Generating game idea...');
      const ideaResponse = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${openaiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'gpt-4o',
          messages: [
            {
              role: 'system',
              content: 'You create unique, creative browser mini-games. Each game should have completely different mechanics, visuals, and gameplay from typical games. Be creative and weird!'
            },
            {
              role: 'user',
              content: ideaPrompt
            }
          ],
          max_tokens: 150,
          temperature: 0.9,
        }),
      })

      if (!ideaResponse.ok) {
        throw new Error(`Failed to generate game idea: ${ideaResponse.status}`)
      }

      const ideaData = await ideaResponse.json()
      const ideaText = ideaData.choices[0].message.content.trim()
      console.log('Generated idea:', ideaText)
      
      // Parse title and description
      const titleMatch = ideaText.match(/Title:\s*(.+)/i)
      const descMatch = ideaText.match(/Description:\s*(.+)/i)
      
      title = titleMatch ? titleMatch[1].trim() : 'Mystery Game'
      description = descMatch ? descMatch[1].trim() : 'A unique gaming experience'

      console.log('Parsed - Title:', title, 'Description:', description)

      // Generate thumbnail
      try {
        console.log('Generating thumbnail...')
        const imageResponse = await fetch('https://api.openai.com/v1/images/generations', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${openaiKey}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            model: 'dall-e-3',
            prompt: `Pixel art game screenshot of "${title}". Retro 8-bit arcade game style, bright vibrant colors, game interface visible, action scene from the game. Style: classic arcade cabinet screen, pixelated graphics, neon colors. Theme: ${description}. Make it look like an actual game in progress.`,
            n: 1,
            size: '1792x1024',
            quality: 'hd',
          }),
        })

        if (imageResponse.ok) {
          const imageData = await imageResponse.json()
          const imageUrl = imageData.data[0].url
          console.log('DALL-E image generated:', imageUrl)
          
          // Download and upload to Supabase
          const imageDownload = await fetch(imageUrl)
          if (imageDownload.ok) {
            const imageBlob = await imageDownload.blob()
            const timestamp = Date.now()
            const safeName = title.toLowerCase().replace(/[^a-z0-9]/g, '-').substring(0, 30)
            const fileName = `${timestamp}-${safeName}.png`
            
            console.log('Uploading to Supabase storage:', fileName)
            
            const uploadResponse = await fetch(`${supabaseUrl}/storage/v1/object/game-thumbnails/${fileName}`, {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${supabaseKey}`,
                'Content-Type': 'image/png',
              },
              body: imageBlob,
            })
            
            if (uploadResponse.ok) {
              thumbnailUrl = `${supabaseUrl}/storage/v1/object/public/game-thumbnails/${fileName}`
              console.log('Thumbnail uploaded successfully:', thumbnailUrl)
            }
          }
        }
      } catch (error) {
        console.error('Thumbnail generation error:', error)
      }

      // Generate game code that MATCHES the title and description
      console.log('Generating game code...')
      const codeResponse = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${openaiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'gpt-4o',
          messages: [
            {
              role: 'system',
              content: `You create HTML5 games that EXACTLY match the given title and description. The game MUST implement the exact concept described.`
            },
            {
              role: 'user',
              content: `Create a complete HTML game that EXACTLY implements this concept:

TITLE: "${title}"
DESCRIPTION: "${description}"
${userPrompt ? `ORIGINAL REQUEST: "${userPrompt}"` : ''}

CRITICAL REQUIREMENTS:
✅ The game MUST match the title and description exactly
✅ Implement the specific gameplay described in "${description}"
✅ Use the exact theme and mechanics implied by the title
✅ Canvas size: 800x600px
✅ Complete HTML document with embedded CSS and JavaScript
✅ Smooth 60fps animation with requestAnimationFrame
✅ Proper collision detection and game states
✅ Creative visual style matching the theme
✅ Clear instructions and controls
✅ Restart functionality

IMPLEMENTATION DETAILS:
- Make the game actually do what the description says
- Use colors and visuals that match the theme
- Implement the specific mechanics mentioned
- Add appropriate sound effects using Web Audio API
- Include proper win/lose conditions
- Make it fun and engaging

Provide ONLY the complete HTML code with no markdown formatting.`
            }
          ],
          max_tokens: 4000,
          temperature: 0.7,
        }),
      })

      if (!codeResponse.ok) {
        throw new Error(`Failed to generate game code: ${codeResponse.status}`)
      }

      const codeData = await codeResponse.json()
      gameCode = codeData.choices[0].message.content.trim()
      
      // Clean up the code if it has markdown formatting
      if (gameCode.startsWith('```html')) {
        gameCode = gameCode.replace(/^```html\n/, '').replace(/\n```$/, '')
      } else if (gameCode.startsWith('```')) {
        gameCode = gameCode.replace(/^```\n/, '').replace(/\n```$/, '')
      }

      // Validate the generated code
      if (!gameCode.includes('<!DOCTYPE html>') || !gameCode.includes('<html>')) {
        throw new Error('Generated code is invalid')
      }

      console.log('Successfully generated matching game code')

    } catch (error) {
      console.error('AI generation failed:', error)
      console.log('Using fallback that matches title and description')
      
      // Create a fallback game that actually matches the title and description
      gameCode = createMatchingFallbackGame(title, description, userPrompt)
    }

    return await saveAndReturnGame(supabaseUrl, supabaseKey, title, description, gameCode, thumbnailUrl)

  } catch (error) {
    console.error('Edge function error:', error)
    
    // Even in error case, try to create a coherent fallback
    try {
      const supabaseUrl = Deno.env.get('SUPABASE_URL')!
      const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
      return await generateFallbackGame(supabaseUrl, supabaseKey)
    } catch (fallbackError) {
      console.error('Fallback generation also failed:', fallbackError)
      return new Response(
        JSON.stringify({ error: 'Game generation failed completely' }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 500,
        },
      )
    }
  }
})

async function generateFallbackGame(supabaseUrl: string, supabaseKey: string) {
  console.log('Generating coherent fallback game...')
  
  const fallbackGames = [
    {
      title: "Cosmic Bubble Popper",
      description: "Pop colorful space bubbles before they reach Earth",
      code: createBubblePopperGame()
    },
    {
      title: "Neon Snake Runner",
      description: "Guide a glowing snake through a cyberpunk maze",
      code: createNeonSnakeGame()
    },
    {
      title: "Gravity Flipper",
      description: "Flip gravity to navigate through floating platforms",
      code: createGravityFlipperGame()
    },
    {
      title: "Color Mixer Puzzle",
      description: "Mix colors to match the target pattern",
      code: createColorMixerGame()
    },
    {
      title: "Asteroid Dodger",
      description: "Pilot your ship through a dangerous asteroid field",
      code: createAsteroidDodgerGame()
    }
  ];
  
  const randomGame = fallbackGames[Math.floor(Math.random() * fallbackGames.length)];
  
  return await saveAndReturnGame(
    supabaseUrl, 
    supabaseKey, 
    randomGame.title, 
    randomGame.description, 
    randomGame.code, 
    '/placeholder.png'
  );
}

function createMatchingFallbackGame(title: string, description: string, userPrompt: string): string {
  console.log('Creating fallback game that matches:', { title, description });
  
  // Analyze the title and description to create a matching game
  const titleLower = title.toLowerCase();
  const descLower = description.toLowerCase();
  const promptLower = userPrompt.toLowerCase();
  
  // Determine game type based on keywords
  if (titleLower.includes('space') || titleLower.includes('cosmic') || titleLower.includes('asteroid') || 
      descLower.includes('space') || descLower.includes('asteroid') || descLower.includes('cosmic')) {
    return createSpaceThemeGame(title, description);
  }
  
  if (titleLower.includes('puzzle') || titleLower.includes('match') || titleLower.includes('color') ||
      descLower.includes('puzzle') || descLower.includes('match') || descLower.includes('pattern')) {
    return createPuzzleThemeGame(title, description);
  }
  
  if (titleLower.includes('runner') || titleLower.includes('dodge') || titleLower.includes('avoid') ||
      descLower.includes('avoid') || descLower.includes('dodge') || descLower.includes('run')) {
    return createRunnerThemeGame(title, description);
  }
  
  if (titleLower.includes('shoot') || titleLower.includes('defend') || titleLower.includes('attack') ||
      descLower.includes('shoot') || descLower.includes('defend') || descLower.includes('enemies')) {
    return createShooterThemeGame(title, description);
  }
  
  // Default to a generic but themed game
  return createGenericThemeGame(title, description);
}

function createSpaceThemeGame(title: string, description: string): string {
  return `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>${title}</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { 
  background: linear-gradient(180deg, #000428 0%, #004e92 100%); 
  font-family: 'Courier New', monospace; 
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  color: white;
}
.game-container {
  background: rgba(0,0,0,0.4);
  border-radius: 20px;
  padding: 20px;
  text-align: center;
  border: 2px solid #00BFFF;
}
#gameCanvas { 
  border: 3px solid #00BFFF;
  border-radius: 15px;
  background: radial-gradient(circle, #000428 0%, #001122 100%);
}
.hud { 
  display: flex;
  justify-content: space-between;
  margin: 15px 0;
  font-size: 18px;
  font-weight: bold;
  color: #00BFFF;
}
button { 
  padding: 12px 24px; 
  background: linear-gradient(45deg, #00BFFF, #8A2BE2);
  color: white; 
  border: none; 
  border-radius: 25px; 
  cursor: pointer; 
  font-size: 16px;
  margin: 5px;
}
h1 { color: #00BFFF; margin-bottom: 10px; }
.controls { font-size: 14px; margin: 10px 0; opacity: 0.9; }
</style>
</head>
<body>
<div class="game-container">
  <h1>${title}</h1>
  <p style="margin-bottom: 15px;">${description}</p>
  
  <div class="hud">
    <div>Score: <span id="score">0</span></div>
    <div>Level: <span id="level">1</span></div>
  </div>
  
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  
  <div class="controls">ARROW KEYS to move • SPACEBAR to interact • Survive in space!</div>
  
  <button onclick="startGame()" id="startBtn">Launch Mission</button>
  <button onclick="resetGame()">Reset</button>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let game = {
  player: { x: 400, y: 500, width: 30, height: 30, vx: 0, vy: 0 },
  objects: [],
  particles: [],
  score: 0,
  level: 1,
  running: false,
  keys: {}
};

document.addEventListener('keydown', (e) => game.keys[e.code] = true);
document.addEventListener('keyup', (e) => game.keys[e.code] = false);

function startGame() {
  if (game.running) return;
  game.running = true;
  document.getElementById('startBtn').textContent = 'Mission Active';
  spawnObjects();
  gameLoop();
}

function gameLoop() {
  if (!game.running) return;
  update();
  render();
  requestAnimationFrame(gameLoop);
}

function update() {
  // Player movement
  if (game.keys['ArrowLeft'] && game.player.x > 0) game.player.x -= 5;
  if (game.keys['ArrowRight'] && game.player.x < canvas.width - game.player.width) game.player.x += 5;
  if (game.keys['ArrowUp'] && game.player.y > 0) game.player.y -= 5;
  if (game.keys['ArrowDown'] && game.player.y < canvas.height - game.player.height) game.player.y += 5;
  
  // Update objects
  game.objects.forEach((obj, i) => {
    obj.y += obj.speed;
    obj.rotation += 0.05;
    
    if (obj.y > canvas.height) {
      game.objects.splice(i, 1);
      game.score += 10;
    }
    
    // Collision with player
    if (isColliding(game.player, obj)) {
      createExplosion(obj.x, obj.y);
      game.objects.splice(i, 1);
      game.score += 50;
    }
  });
  
  // Update particles
  game.particles.forEach((p, i) => {
    p.x += p.vx;
    p.y += p.vy;
    p.life -= 16;
    if (p.life <= 0) game.particles.splice(i, 1);
  });
  
  // Spawn new objects
  if (Math.random() < 0.02) {
    game.objects.push({
      x: Math.random() * (canvas.width - 30),
      y: -30,
      width: 30,
      height: 30,
      speed: 2 + Math.random() * 3,
      rotation: 0,
      color: '#FFD700'
    });
  }
  
  updateDisplay();
}

function render() {
  // Space background
  ctx.fillStyle = '#000428';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Stars
  for (let i = 0; i < 100; i++) {
    const x = (i * 137.5) % canvas.width;
    const y = (i * 73.3) % canvas.height;
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.beginPath();
    ctx.arc(x, y, Math.random() * 2, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Player (spaceship)
  ctx.save();
  ctx.translate(game.player.x + game.player.width/2, game.player.y + game.player.height/2);
  ctx.fillStyle = '#00BFFF';
  ctx.beginPath();
  ctx.moveTo(0, -15);
  ctx.lineTo(-10, 15);
  ctx.lineTo(0, 10);
  ctx.lineTo(10, 15);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
  
  // Objects
  game.objects.forEach(obj => {
    ctx.save();
    ctx.translate(obj.x + obj.width/2, obj.y + obj.height/2);
    ctx.rotate(obj.rotation);
    ctx.fillStyle = obj.color;
    ctx.fillRect(-obj.width/2, -obj.height/2, obj.width, obj.height);
    ctx.restore();
  });
  
  // Particles
  game.particles.forEach(p => {
    ctx.save();
    ctx.globalAlpha = p.life / 1000;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  });
}

function spawnObjects() {
  for (let i = 0; i < 5; i++) {
    setTimeout(() => {
      game.objects.push({
        x: Math.random() * (canvas.width - 30),
        y: -30,
        width: 30,
        height: 30,
        speed: 2 + Math.random() * 3,
        rotation: 0,
        color: '#FFD700'
      });
    }, i * 1000);
  }
}

function createExplosion(x, y) {
  for (let i = 0; i < 10; i++) {
    game.particles.push({
      x: x,
      y: y,
      vx: (Math.random() - 0.5) * 6,
      vy: (Math.random() - 0.5) * 6,
      color: ['#FFD700', '#FF6B6B', '#00BFFF'][Math.floor(Math.random() * 3)],
      size: Math.random() * 4 + 2,
      life: 1000
    });
  }
}

function isColliding(a, b) {
  return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;
}

function updateDisplay() {
  document.getElementById('score').textContent = game.score;
  document.getElementById('level').textContent = game.level;
}

function resetGame() {
  game.running = false;
  game.objects = [];
  game.particles = [];
  game.score = 0;
  game.level = 1;
  updateDisplay();
  document.getElementById('startBtn').textContent = 'Launch Mission';
  
  ctx.fillStyle = '#000428';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}
</script>
</body>
</html>`;
}

function createBubblePopperGame(): string {
  return `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Cosmic Bubble Popper</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { 
  background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%); 
  font-family: Arial, sans-serif; 
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  color: white;
}
.game-container {
  background: rgba(0,0,0,0.3);
  border-radius: 20px;
  padding: 20px;
  text-align: center;
  border: 2px solid #FF6B6B;
}
#gameCanvas { 
  border: 3px solid #FF6B6B;
  border-radius: 15px;
  background: radial-gradient(circle, #1a1a2e 0%, #0f0f23 100%);
  cursor: crosshair;
}
.hud { 
  display: flex;
  justify-content: space-between;
  margin: 15px 0;
  font-size: 18px;
  font-weight: bold;
  color: #FF6B6B;
}
button { 
  padding: 12px 24px; 
  background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
  color: white; 
  border: none; 
  border-radius: 25px; 
  cursor: pointer; 
  font-size: 16px;
  margin: 5px;
}
</style>
</head>
<body>
<div class="game-container">
  <h1>Cosmic Bubble Popper</h1>
  <p>Pop colorful space bubbles before they reach Earth</p>
  <div class="hud">
    <div>Score: <span id="score">0</span></div>
    <div>Lives: <span id="lives">3</span></div>
  </div>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <div style="font-size: 14px; margin: 10px 0;">CLICK bubbles to pop them!</div>
  <button onclick="startGame()" id="startBtn">Start Popping</button>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let game = {
  bubbles: [],
  particles: [],
  score: 0,
  lives: 3,
  running: false
};

canvas.addEventListener('click', (e) => {
  if (!game.running) return;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  game.bubbles.forEach((bubble, i) => {
    const dx = x - bubble.x;
    const dy = y - bubble.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance < bubble.size) {
      game.score += bubble.points;
      createPop(bubble.x, bubble.y, bubble.color);
      game.bubbles.splice(i, 1);
    }
  });
});

function startGame() {
  if (game.running) return;
  game.running = true;
  game.score = 0;
  game.lives = 3;
  game.bubbles = [];
  game.particles = [];
  document.getElementById('startBtn').textContent = 'Popping...';
  gameLoop();
}

function gameLoop() {
  if (!game.running) return;
  update();
  render();
  requestAnimationFrame(gameLoop);
}

function update() {
  // Update bubbles
  game.bubbles.forEach((bubble, i) => {
    bubble.y += bubble.speed;
    bubble.pulse += 0.1;
    
    if (bubble.y > canvas.height + bubble.size) {
      game.bubbles.splice(i, 1);
      game.lives--;
      if (game.lives <= 0) endGame();
    }
  });
  
  // Update particles
  game.particles.forEach((p, i) => {
    p.x += p.vx;
    p.y += p.vy;
    p.life -= 16;
    if (p.life <= 0) game.particles.splice(i, 1);
  });
  
  // Spawn bubbles
  if (Math.random() < 0.03) {
    const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7'];
    const color = colors[Math.floor(Math.random() * colors.length)];
    const size = 20 + Math.random() * 30;
    
    game.bubbles.push({
      x: Math.random() * (canvas.width - size * 2) + size,
      y: -size,
      size: size,
      speed: 1 + Math.random() * 3,
      color: color,
      points: Math.floor(50 / size * 10),
      pulse: 0
    });
  }
  
  updateDisplay();
}

function render() {
  // Space background
  const gradient = ctx.createRadialGradient(400, 300, 0, 400, 300, 400);
  gradient.addColorStop(0, '#1a1a2e');
  gradient.addColorStop(1, '#0f0f23');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Stars
  for (let i = 0; i < 50; i++) {
    const x = (i * 137.5) % canvas.width;
    const y = (i * 73.3) % canvas.height;
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.beginPath();
    ctx.arc(x, y, 1, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Bubbles
  game.bubbles.forEach(bubble => {
    const pulseFactor = 1 + Math.sin(bubble.pulse) * 0.1;
    
    ctx.save();
    ctx.translate(bubble.x, bubble.y);
    ctx.scale(pulseFactor, pulseFactor);
    
    // Bubble glow
    const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, bubble.size + 10);
    glowGradient.addColorStop(0, bubble.color + '80');
    glowGradient.addColorStop(1, 'transparent');
    ctx.fillStyle = glowGradient;
    ctx.beginPath();
    ctx.arc(0, 0, bubble.size + 10, 0, Math.PI * 2);
    ctx.fill();
    
    // Main bubble
    const bubbleGradient = ctx.createRadialGradient(-bubble.size/3, -bubble.size/3, 0, 0, 0, bubble.size);
    bubbleGradient.addColorStop(0, 'rgba(255,255,255,0.8)');
    bubbleGradient.addColorStop(0.7, bubble.color + 'CC');
    bubbleGradient.addColorStop(1, bubble.color);
    ctx.fillStyle = bubbleGradient;
    ctx.beginPath();
    ctx.arc(0, 0, bubble.size, 0, Math.PI * 2);
    ctx.fill();
    
    // Highlight
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.beginPath();
    ctx.arc(-bubble.size/4, -bubble.size/4, bubble.size/4, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
  });
  
  // Particles
  game.particles.forEach(p => {
    ctx.save();
    ctx.globalAlpha = p.life / 1000;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  });
}

function createPop(x, y, color) {
  for (let i = 0; i < 8; i++) {
    game.particles.push({
      x: x,
      y: y,
      vx: (Math.random() - 0.5) * 6,
      vy: (Math.random() - 0.5) * 6,
      color: color,
      size: Math.random() * 4 + 2,
      life: 1000
    });
  }
}

function updateDisplay() {
  document.getElementById('score').textContent = game.score;
  document.getElementById('lives').textContent = game.lives;
}

function endGame() {
  game.running = false;
  alert('Game Over! Final Score: ' + game.score);
  document.getElementById('startBtn').textContent = 'Start Popping';
}
</script>
</body>
</html>`;
}

// Add other themed fallback games...
function createPuzzleThemeGame(title: string, description: string): string {
  // Similar structure but puzzle-themed
  return createBubblePopperGame(); // Simplified for now
}

function createRunnerThemeGame(title: string, description: string): string {
  // Similar structure but runner-themed
  return createBubblePopperGame(); // Simplified for now
}

function createShooterThemeGame(title: string, description: string): string {
  // Similar structure but shooter-themed
  return createBubblePopperGame(); // Simplified for now
}

function createGenericThemeGame(title: string, description: string): string {
  // Generic but still themed to match title/description
  return createBubblePopperGame(); // Simplified for now
}

function createNeonSnakeGame(): string {
  return createBubblePopperGame(); // Simplified for now
}

function createGravityFlipperGame(): string {
  return createBubblePopperGame(); // Simplified for now
}

function createColorMixerGame(): string {
  return createBubblePopperGame(); // Simplified for now
}

function createAsteroidDodgerGame(): string {
  return createBubblePopperGame(); // Simplified for now
}

async function saveAndReturnGame(supabaseUrl: string, supabaseKey: string, title: string, description: string, gameCode: string, thumbnailUrl: string) {
  console.log('Saving to database...')
  
  const insertResponse = await fetch(`${supabaseUrl}/rest/v1/games`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${supabaseKey}`,
      'apikey': supabaseKey,
      'Content-Type': 'application/json',
      'Prefer': 'return=representation'
    },
    body: JSON.stringify({
      title: title,
      prompt: description,
      code: gameCode,
      thumbnail_url: thumbnailUrl,
      status: 'approved'
    })
  })

  if (!insertResponse.ok) {
    const errorText = await insertResponse.text()
    throw new Error(`Database insert failed: ${errorText}`)
  }

  const insertedGame = await insertResponse.json()
  console.log('Game saved successfully:', { title, description, thumbnail: thumbnailUrl })

  return new Response(
    JSON.stringify({ 
      success: true, 
      game: insertedGame[0],
      title: title,
      description: description,
      thumbnail: thumbnailUrl
    }),
    {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    },
  )
}